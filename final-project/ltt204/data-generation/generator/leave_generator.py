"""
Leave Module Data Generation

This module contains all data generation functions for the Leave module,
including leave types, holidays, entitlements, requests, and leave records.

IMPORTANT: All leave-related data uses emp_number from the employees DataFrame
generated by pim_generator.py. Employee numbers start from 2 because emp_number=1
is reserved for the OrangeHRM admin account.
"""

import pandas as pd
import random
from datetime import datetime, timedelta
from typing import Tuple, Dict
from config import (
    fake, TODAY,
    LEAVE_TYPES_MASTER, LEAVE_STATUSES, ENTITLEMENT_TYPES
)


def generate_leave_types() -> pd.DataFrame:
    """
    Generate LeaveType (Master Data).

    Independent entity - create early.
    """
    print("Generating Leave Types...")
    return pd.DataFrame(LEAVE_TYPES_MASTER)


def generate_holidays() -> pd.DataFrame:
    """
    Generate Holiday (Master Data).

    Independent entity - create early.
    """
    print("Generating Holidays...")

    records = []
    record_id = 1

    # 12-15 holidays per year
    for _ in range(random.randint(12, 15)):
        start_date_obj = datetime.strptime('2025-01-01', '%Y-%m-%d').date()
        end_date_obj = datetime.strptime('2025-12-31', '%Y-%m-%d').date()
        holiday_date = fake.date_between(start_date=start_date_obj, end_date=end_date_obj)

        # Some holidays are multi-day (0.5) or single day (1.0)
        length_in_days = random.choice([0.5, 1.0])
        to_date = holiday_date + timedelta(days=int(length_in_days))

        records.append({
            'id': record_id,
            'description': fake.word().title() + ' Holiday',
            'date': holiday_date.strftime('%Y-%m-%d'),
            'recurring': random.choice([0, 1]),
            'length': int(length_in_days),  # 0 or 1 (full day or half day as int)
            'operational_country_id': None,
        })
        record_id += 1

    return pd.DataFrame(records)


def generate_work_weeks() -> pd.DataFrame:
    """
    Generate WorkWeek (Configuration).

    Independent entity - create early.
    Typically 1-3 work week patterns.
    """
    print("Generating Work Week configurations...")

    records = [
        {
            'id': 1,
            'operational_country_id': None,
            'mon': 8,
            'tue': 8,
            'wed': 8,
            'thu': 8,
            'fri': 8,
            'sat': 0,
            'sun': 0,
        },
    ]

    return pd.DataFrame(records)


def generate_leave_periods() -> pd.DataFrame:
    """
    Generate LeavePeriodHistory (Fiscal Year Configuration).

    Independent entity - create early.
    Stores leave period start month/day.
    """
    print("Generating Leave Period History...")

    records = [
        {
            'id': 1,
            'leave_period_start_month': 1,
            'leave_period_start_day': 1,
            'created_at': '2024-01-01',
        },
        {
            'id': 2,
            'leave_period_start_month': 1,
            'leave_period_start_day': 1,
            'created_at': '2025-01-01',
        },
    ]

    return pd.DataFrame(records)


def generate_leave_entitlements(employees_df: pd.DataFrame, leave_types_df: pd.DataFrame,
                                leave_periods_df: pd.DataFrame) -> pd.DataFrame:
    """
    Generate LeaveEntitlement (Depends on Employee, LeaveType, LeavePeriod).

    One entitlement per Employee-LeaveType-Period combo.
    Must exist before LeaveRequest can be created.
    """
    print("Generating Leave Entitlements...")

    records = []
    record_id = 1

    for _, emp in employees_df.iterrows():
        for _, leave_type in leave_types_df.iterrows():
            for _, period in leave_periods_df.iterrows():
                # Allocate days based on leave type
                if leave_type['name'] == 'Annual Leave':
                    no_of_days = random.uniform(15, 30)
                elif leave_type['name'] == 'Sick Leave':
                    no_of_days = random.uniform(5, 15)
                else:
                    no_of_days = random.uniform(0, 10)

                from_date = datetime(2025 if period['id'] == 2 else 2024, 1, 1)
                to_date = datetime(2025 if period['id'] == 2 else 2024, 12, 31)
                
                records.append({
                    'id': record_id,
                    'emp_number': emp['emp_number'],
                    'no_of_days': round(no_of_days, 15),  # decimal(19,15)
                    'days_used': 0.0,
                    'leave_type_id': leave_type['id'],
                    'from_date': from_date.strftime('%Y-%m-%d'),
                    'to_date': to_date.strftime('%Y-%m-%d'),
                    'credited_date': from_date.strftime('%Y-%m-%d'),
                    'note': None,
                    'entitlement_type': 1,
                    'deleted': 0,
                    'created_by_id': None,
                    'created_by_name': None,
                })
                record_id += 1

    return pd.DataFrame(records)


def generate_leave_requests(employees_df: pd.DataFrame, leave_types_df: pd.DataFrame,
                           leave_entitlements_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
    """
    Generate LeaveRequest (Depends on Employee, LeaveType, LeaveEntitlement).

    2-5 requests per employee, 40-50% of employees sampled.
    Note: ohrm_leave_request table has minimal fields in actual schema.
    Status and approval tracking is in ohrm_leave table.
    """
    print("Generating Leave Requests...")

    # Sample 40-50% of employees
    sampled_employees = employees_df.sample(frac=random.uniform(0.4, 0.5))
    
    # Check if employment_status column exists (might be a helper column)
    if 'employment_status' in employees_df.columns:
        active_employees = employees_df[employees_df['employment_status'] == 'ACTIVE']
    else:
        # If not, assume all employees without termination_id are active
        active_employees = employees_df[employees_df['termination_id'].isna()]

    records = []
    leave_request_map = {}  # Map of (emp_number, leave_type_id, request_id) -> number_of_days
    record_id = 1

    for _, emp in sampled_employees.iterrows():
        num_requests = random.randint(2, 5)

        for _ in range(num_requests):
            leave_type = leave_types_df.sample(1).iloc[0]

            # Get entitlement for this employee and leave type
            emp_entitlements = leave_entitlements_df[
                (leave_entitlements_df['emp_number'] == emp['emp_number']) &
                (leave_entitlements_df['leave_type_id'] == leave_type['id'])
            ]

            if len(emp_entitlements) == 0:
                continue

            entitlement = emp_entitlements.iloc[0]
            available_balance = entitlement['no_of_days']

            # Request between 0.5 and min(10, available_balance) days
            number_of_days = min(random.uniform(0.5, 10), available_balance)
            number_of_days = round(number_of_days, 2)

            # Parse period dates from string to datetime objects
            period_start = datetime.strptime(entitlement['from_date'], '%Y-%m-%d').date()
            period_end = datetime.strptime(entitlement['to_date'], '%Y-%m-%d').date()

            # Generate application date
            from_date = fake.date_between(start_date=period_start, end_date=period_end)

            records.append({
                'id': record_id,
                'leave_type_id': leave_type['id'],
                'date_applied': from_date.strftime('%Y-%m-%d'),
                'emp_number': emp['emp_number'],
                'comments': fake.sentence() if random.random() > 0.5 else '',
            })

            # Store for leave record generation (track how many days and dates)
            to_date = from_date + timedelta(days=int(number_of_days))
            if to_date > period_end:
                to_date = period_end
            leave_request_map[(emp['emp_number'], leave_type['id'], record_id)] = {
                'number_of_days': number_of_days,
                'from_date': from_date,
                'to_date': to_date,
            }
            record_id += 1

    return pd.DataFrame(records), leave_request_map


def generate_leave_request_comments(leave_requests_df: pd.DataFrame,
                                   employees_df: pd.DataFrame) -> pd.DataFrame:
    """
    Generate LeaveRequestComment (Depends on LeaveRequest, Employee).

    1-2 comments per APPROVED or REJECTED request.
    """
    print("Generating Leave Request Comments...")

    # Filter for requests that might have comments (random 50%)
    commented_requests = leave_requests_df.sample(frac=0.5)

    records = []
    record_id = 1
    
    # Check if employment_status column exists
    if 'employment_status' in employees_df.columns:
        active_employees = employees_df[employees_df['employment_status'] == 'ACTIVE']
    else:
        active_employees = employees_df[employees_df['termination_id'].isna()]

    for _, request in commented_requests.iterrows():
        num_comments = random.randint(1, 2)

        for _ in range(num_comments):
            commenter = active_employees.sample(1).iloc[0] if len(active_employees) > 0 else None

            if commenter is not None:
                # Parse dates from string to datetime objects
                start_dt = datetime.strptime(request['date_applied'], '%Y-%m-%d')
                end_dt = datetime.now()

                created_date = fake.date_time_between(
                    start_date=start_dt,
                    end_date=end_dt
                )

                # Build name from employee data
                first_name = commenter.get('emp_firstname', 'Unknown')
                last_name = commenter.get('emp_lastname', 'User')
                
                records.append({
                    'id': record_id,
                    'leave_request_id': request['id'],
                    'created': created_date.strftime('%Y-%m-%d %H:%M:%S'),
                    'created_by_name': f"{first_name} {last_name}",
                    'created_by_id': None,
                    'created_by_emp_number': int(commenter['emp_number']),
                    'comments': fake.sentence(),
                })
                record_id += 1

    return pd.DataFrame(records) if records else pd.DataFrame()


def generate_leaves(leave_requests_df: pd.DataFrame, leave_request_map: Dict) -> pd.DataFrame:
    """
    Generate Leave (Individual Leave Record - Depends on LeaveRequest).

    One record per day for each leave request.
    Uses leave_request_map to get date ranges.
    """
    print("Generating Leave records...")

    records = []
    record_id = 1

    for _, request in leave_requests_df.iterrows():
        # Find corresponding date info from map
        request_key = None
        for key, value in leave_request_map.items():
            if key[2] == request['id']:  # Match on request ID
                request_key = key
                break
        
        if request_key is None:
            continue
            
        leave_info = leave_request_map[request_key]
        from_date = leave_info['from_date']
        to_date = leave_info['to_date']
        number_of_days = leave_info['number_of_days']

        current_date = from_date
        days_created = 0
        
        # Random status for each leave record
        status_options = [-1, 1, 2, 0, 3]  # PENDING, APPROVED, REJECTED, CANCELLED, TAKEN
        status_int = random.choices(status_options, weights=[10, 60, 5, 5, 20], k=1)[0]

        while current_date <= to_date and days_created < int(number_of_days) + 1:
            # Random chance of half-day vs full day
            duration = random.choice([0.5, 1.0])

            records.append({
                'id': record_id,
                'date': current_date.strftime('%Y-%m-%d'),
                'length_hours': None,
                'length_days': duration,
                'status': status_int,
                'comments': '',
                'leave_request_id': request['id'],
                'leave_type_id': request['leave_type_id'],
                'emp_number': request['emp_number'],
                'start_time': None,
                'end_time': None,
                'duration_type': 0 if duration == 1.0 else random.choice([1, 2]),
            })

            record_id += 1
            current_date = current_date + timedelta(days=1)
            days_created += duration

    return pd.DataFrame(records) if records else pd.DataFrame()
